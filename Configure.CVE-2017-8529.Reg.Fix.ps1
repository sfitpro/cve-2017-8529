<#
    .SYNOPSIS
    A PowerShell script to configure the registry fix in CVE-2017-8529.

    .DESCRIPTION
    A PowerShell script to configure the registry fix in CVE-2017-8529.
    See https://portal.msrc.microsoft.com/en-US/security-guidance/advisory/CVE-2017-8529
    Install the updates for CVE-2017-8529 before configuring the registry fix.

    .PARAMETER Computers
    Specfiies the computers to be conigured

    .INPUTS
    None.

    .OUTPUTS
    A log file is generated.

    .NOTES
    Created By:     Eddie Lu
    Last Update:    02/07/2020
    Version:        20200201 - first version

    .EXAMPLE
    C:\PS> .\Configure.CVE-2017-8529.Reg.Fix.ps1 -Computers computer1,computer2
#>

[CmdletBinding()]
Param (
    [Parameter(Mandatory=$True)]
    [ValidateNotNull()]
    [string[]]$Computers
)

Set-StrictMode -Version Latest

if ($PSBoundParameters['Debug']) {
    $DebugPreference = 'Continue'
}

$LogPath = $PSScriptRoot
$StartTime = Get-Date
$TimeStamp = $StartTime.ToString("yyyyMMdd_HHmmss")
$LogFile = $LogPath + "\$TimeStamp.txt"

$Cxn = @{
    Ping = '';
}

$HKLM = [Microsoft.Win32.RegistryHive]::LocalMachine
$OS32SubKeyPath = 'SOFTWARE\Microsoft\Internet Explorer\Main\FeatureControl'
$OS64SubKeyPath = 'SOFTWARE\WOW6432Node\Microsoft\Internet Explorer\Main\FeatureControl'
$SubKeyName = 'FEATURE_ENABLE_PRINT_INFO_DISCLOSURE_FIX'
$ValueName = 'iexplore.exe'
$ValueData = 1

foreach ($Computer in $Computers) {

    $IndexCount = $Computers.Count
    $IndexLength = $(($Computers.Count).ToString()).Length
    $Index = [Array]::IndexOf($Computers, $Computer) + 1
    $Index = "{0:d$($IndexLength)}" -f $Index

    if (Test-Connection -ComputerName $Computer -Count 1 -Quiet) {
        $Cxn.Ping = $True
    }
    else {
        $Cxn.Ping = $False
    }

    Write-Debug "[$($Index) - $($IndexCount)] $Computer - Ping:$($Cxn.Ping)"

    if ($Cxn.Ping) {
        Write-Debug "[$($Index) - $($IndexCount)] $Computer - pingable"

        try {
            $OSArchitecture = (Get-CimInStance -ClassName CIM_OperatingSystem -ComputerName $Computer -ErrorAction SilentlyContinue).OSArchitecture
            Write-Debug "[$($Index) - $($IndexCount)] $Computer - OS architecture: $OSArchitecture"
        }
        catch {
            Write-Output "[$($Index) - $($IndexCount)] $Computer - failed to connect via WinRM" | Add-Content -Path $LogFile -Encoding Ascii -PassThru
            continue
        } 
        
        if ($OSArchitecture -eq '64-bit') {
            $SubKeyPaths = @($OS32SubKeyPath, $OS64SubKeyPath)
        }
        else {
            $SubKeyPaths = @($OS32SubKeyPath)
        }
        
        try {
            $BaseKey = [Microsoft.Win32.RegistryKey]::OpenRemoteBaseKey($HKLM, $Computer)           
        }
        catch{
            Write-Output "[$($Index) - $($IndexCount)] $Computer - failed to connect to registry" | Add-Content -Path $LogFile -Encoding Ascii -PassThru
            continue
        }

        foreach ($SubKeyPath in $SubKeyPaths) {
            $SubKeyPathName = $SubKeyPath + "\$SubKeyName"
            $SubKey = $BaseKey.OpenSubKey($SubKeyPathName, $True)

            ### when $SubKey is $null, the $SubKey does not exist
            if ($null -ne $SubKey) {
                Write-Debug "[$($Index) - $($IndexCount)] $Computer - registry key path: $SubKey"
                Write-Debug "[$($Index) - $($IndexCount)] $Computer - registry key value name & data: $ValueName & $($SubKey.GetValue($ValueName))"

                ### when the return value is not equal to $ValueData, set it to $ValueData
                if ($ValueData -ne $SubKey.GetValue($ValueName)) {
                    $SubKey.SetValue($ValueName,$ValueData,[Microsoft.Win32.RegistryValueKind]::DWORD)
                    Write-Output "[$($Index) - $($IndexCount)] $Computer - $Subkey configured" | Add-Content -Path $LogFile -Encoding Ascii -PassThru
                    Write-Debug "[$($Index) - $($IndexCount)] $Computer - registry key value name & data: $ValueName & $($SubKey.GetValue($ValueName))"
                }
                else {
                    Write-Output "[$($Index) - $($IndexCount)] $Computer - $Subkey already configured, no change" | Add-Content -Path $LogFile -Encoding Ascii -PassThru
                }
            }
            else {
                $SubKey = $BaseKey.OpenSubKey($SubKeyPath, $True).CreateSubKey($SubKeyName)
                $SubKey.SetValue($ValueName,$ValueData,[Microsoft.Win32.RegistryValueKind]::DWORD)
                Write-Output "[$($Index) - $($IndexCount)] $Computer - $Subkey configured" | Add-Content -Path $LogFile -Encoding Ascii -PassThru
            }

        } ### end of foreach loop

    }
    else {
        Write-Output "[$($Index) - $($IndexCount)] $Computer - not pingable" | Add-Content -Path $LogFile -Encoding Ascii -PassThru
    } ### end of check ping

} ### end of foreach loop

$EndTime = Get-Date
$TimeSpan = New-TimeSpan -Start $StartTime -End $EndTime
Write-Output "`nThe script completed in $TimeSpan`n" | Add-Content -Path $LogFile -Encoding Ascii -PassThru
